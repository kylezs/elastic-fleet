# Default values for elastic-fleet.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: kolide/fleet
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: "latest"

args:
  - "--config"
  - "/etc/fleet/config.yml"

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations:
  seccomp.security.alpha.kubernetes.io/pod: runtime/default

podSecurityContext: {}

securityContext:
  capabilities:
    # drop the default linux superuser capabilities
    drop:
      - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000

# controls which certs are deployed/used by cert manager
certs:
  # May change depending on if using self-signed or letsencrypt staging/prod
  certName: letsencrypt-prod-tls
  # staging, dev, prod
  mode: dev
  # Include root domain and any subdomains used, used by certs
  dnsNames:
    - example.com
    - fleet.example.com
  # Used by ingresses, to direct traffic to particular subdomains
  dnsSubdomains:
    kibana: example.com
    fleet: fleet.example.com
  issuer:
    email: example@mail.com


service:
  type: NodePort
  port: 8080

resources: {}

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 1
  targetCPUUtilizationPercentage: 80

fleet:
  # to be handled by secrets
  # auto generated
  # auth:
  #   jwt_key: <placeholder for secret>
  logging:
    debug: false
    json: true
    disable_banner: true
  server:
    tls: true
  filesystem:
    result_volume: /var/log/fleet

mysql:
  # These come from values.secret.yaml (the actual creds will not be in
  # the repo)
  mysqlUsername: <placeholder for secret>
  mysqlPassword: <placeholder for secret>
  mysqlDatabase: <placeholder for secret>
  persistence:
    enabled: true
    existingClaim: mysql-pvc
  podLabels:
    # targetted by network policy
    role: fleet-backend
  # initializationFiles:
  #   mysql-init: |-
  #     UPDATE mysql.user SET authentication_string = PASSWORD('MYSQL_ROOT_PASSWORD')
  #     WHERE User = 'root' AND Host = '%';
  #     UPDATE mysql.user SET authentication_string = PASSWORD('MYSQL_PASSWORD')
  #     WHERE User = 'MYSQL_USER' AND Host = '%';
  #     FLUSH PRIVILEGES;

  # extraInitContainers: |
  #   - name: "update-mysql-init"
  #     image: "busybox:1.29.3"
  #     imagePullPolicy: {{ .Values.imagePullPolicy | quote }}
  #     command: [
  #       "sh",
  #       "-ce",
  #       "cp /docker-entrypoint-initdb.d/mysql-init /tmp/files/mysql-init &&
  #         sed -i \"s/MYSQL_ROOT_PASSWORD/$MYSQL_ROOT_PASSWORD/g\" /tmp/files/mysql-init &&
  #         sed -i \"s/MYSQL_PASSWORD/$MYSQL_PASSWORD/g\" /tmp/files/mysql-init &&
  #         sed -i \"s/MYSQL_USER/$MYSQL_USER/g\" /tmp/files/mysql-init" ]
  #     env:
  #       - name: MYSQL_ROOT_PASSWORD
  #         valueFrom:
  #           secretKeyRef:
  #             name: {{ .Release.Name }}-mysql
  #             key: mysql-password
  #       - name: MYSQL_PASSWORD
  #         valueFrom:
  #           secretKeyRef:
  #             name: {{ .Release.Name }}-mysql
  #             key: mysql-root-password
  #     volumeMounts:
  #       - name: migrations
  #         mountPath: /docker-entrypoint-initdb.d
  #       - name: tmp-files
  #         mountPath: /tmp/files
  # extraVolumes: |
  #   - name: tmp-files
  #     emptyDir: {}
  # extraVolumeMounts: |
  #   - name: tmp-files
  #     mountPath: /tmp/files


redis:
  cluster:
    slaveCount: 0
  master:
    persistence:
      enabled: false
  usePassword: false
  podLabels:
    role: fleet-backend
  # this may break some other stuff
  # networkPolicy.enabled: true

elasticsearch:
  replicas: 1
  volumeClaimTemplate:
    accessModes: ["ReadWriteOnce"]
    resources:
      requests:
        storage: 10Gi
  podSecurityPolicy:
    name: "elasticsecuritypolicy"
    create: true
    spec:
      readOnlyRootFilesystem: true
      privileged: false
      allowPrivilegeEscalation: false
      hostPID: false
      hostNetwork: false
      volumes:
        - persistentVolumeClaim
        - configMap
        - secret
  # Must be https if xpack.security.http.ssl.enabled: true
  # it's the protocol of the readiness probe
  protocol: http
  esConfig:
    elasticsearch.yml: |
      # enabled so authentication / login is enabled
      xpack.security.enabled: true
      xpack.security.transport.ssl.enabled: true
      xpack.security.transport.ssl.verification_mode: certificate
      xpack.security.transport.ssl.keystore.path: /usr/share/elasticsearch/config/certs/elastic-certificates.p12
      xpack.security.transport.ssl.truststore.path: /usr/share/elasticsearch/config/certs/elastic-certificates.p12
      # These should NOT be enabled with a load balancer, the LB should terminate the TLS
      # xpack.security.http.ssl.enabled: true
      # xpack.security.http.ssl.truststore.path: /usr/share/elasticsearch/config/certs/elastic-certificates.p12
      # xpack.security.http.ssl.keystore.path: /usr/share/elasticsearch/config/certs/elastic-certificates.p12
  extraEnvs:
    - name: ELASTIC_PASSWORD
      valueFrom:
        secretKeyRef:
          name: elastic-credentials
          key: password
    - name: ELASTIC_USERNAME
      valueFrom:
        secretKeyRef:
          name: elastic-credentials
          key: username
  # even though we use http (behind the LB), tls is required for transport layer
  # security 
  secretMounts:
    - name: elastic-certificates
      secretName: elastic-certificates
      path: /usr/share/elasticsearch/config/certs

kibana:
  service:
    type: NodePort
  elasticsearchHosts: http://elasticsearch-master:9200/
  # use this custom image, only way to use plugins as of writing
  image: docker.io/kylezs/kibana-elastalert
  imageTag: latest
  protocol: http
  securityContext:
    capabilities:
      # drop the default linux superuser capabilities
      drop:
        - ALL
    # Needs to write a UUID file
    readOnlyRootFilesystem: false
    runAsNonRoot: true
    runAsUser: 1000
  secretMounts:
    - name: elastic-certificate-pem
      secretName: elastic-certificate-pem
      path: /usr/share/kibana/config/certs
  kibanaConfig:
    kibana.yml: |
        # If load balanced, don't need this
        server.ssl:
          enabled: false
          # key: /usr/share/kibana/config/certs/elastic-certificate.pem
          # certificate: /usr/share/kibana/config/certs/elastic-certificate.pem
        xpack.security.enabled: true
        xpack.security.encryptionKey: ${KIBANA_ENCRYPTION_KEY}
        xpack.encrypted_saved_objects.encryptionKey: ${KIBANA_ENCRYPTION_KEY}
        elastalert-kibana-plugin.serverHost: elastalert
        elastalert-kibana-plugin.serverPort: 3030
  extraEnvs:
    - name: ELASTICSEARCH_PASSWORD
      valueFrom:
        secretKeyRef:
          name: elastic-credentials
          key: password
    - name: ELASTICSEARCH_USERNAME
      valueFrom:
        secretKeyRef:
          name: elastic-credentials
          key: username
    - name: KIBANA_ENCRYPTION_KEY
      valueFrom:
        secretKeyRef:
          name: kibana
          key: encryptionkey
  readinessProbe:
    initialDelaySeconds: 30

elastalert:
  elasticsearch:
    host: elasticsearch-master
    port: 9200
    useSsl: false
    verifyCerts: false
    credentialsSecret: elastic-credentials
    credentialsSecretUsernameKey: username
    credentialsSecretPasswordKey: password

# Used to send emails from elastalert
#NB: username and password comes from values.secret.yaml
smtp:
  host: smpt.example.com
  # Must use 465 with the currently used version of elastalert
  port: 465
  useTLS: true
  # where the email appears to come from (best to set to the actual from address)
  # which is set in values.secret.yaml as 'user'
  fromAddress: example@example.com
