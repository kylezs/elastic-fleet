# Default values for kolide-fleet.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: kolide/fleet
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: "latest"

args:
  - "--config"
  - "/etc/fleet/config.yml"

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations:
  seccomp.security.alpha.kubernetes.io/pod: runtime/default

podSecurityContext:
  {}

securityContext:
  capabilities:
    # drop the default linux superuser capabilities
    drop:
    - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000

# Won't be required at all with Ingress Controller
service:
  name: fleet-nodeport
  type: NodePort
  port: 8080

resources:
  {}

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 1
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

fleet:
  # to be handled by secrets
  auth:
    jwt_key: <placeholder for secret>
  logging:
    debug: false
    json: true
    disable_banner: true
  server:
    tls: true
  filesystem:
    result_volume: /var/log/fleet

tls:
  generate: false

mysql:
  # These come from values.secret.yaml (the actual creds will not be in
  # the repo)
  mysqlUsername: <placeholder for secret>
  mysqlPassword: <placeholder for secret>
  mysqlDatabase: <placeholder for secret>
  persistence:
    enabled: true
    existingClaim: kf-mysql-pvc
  podLabels:
    # targetted by network policy
    role: fleet-backend


redis:
  cluster:
    slaveCount: 0
  master:
    persistence:
      enabled: false
  usePassword: false
  podLabels:
    role: fleet-backend
  # this may break some other stuff
  # networkPolicy.enabled: true


elasticsearch:
  replicas: 1
  volumeClaimTemplate:
    accessModes: [ "ReadWriteOnce" ]
    resources:
      requests:
        # default is 30Gi
        storage: 10Gi
  podSecurityPolicy:
    name: "elasticsecuritypolicy"
    create: true
    spec:
      readOnlyRootFilesystem: true
      privileged: false
      allowPrivilegeEscalation: false
      hostPID: false
      hostNetwork: false
      volumes:
      - persistentVolumeClaim
      - configMap
      - secret
  # Must be https if xpack.security.http.ssl.enabled: true
  # it's the protocol of the readiness probe
  protocol: https
  esConfig:
    elasticsearch.yml: |
      xpack.security.audit.enabled: true
      xpack.security.enabled: true
      xpack.security.transport.ssl.enabled: true
      xpack.security.transport.ssl.verification_mode: certificate
      xpack.security.transport.ssl.keystore.path: /usr/share/elasticsearch/config/certs/elastic-certificates.p12
      xpack.security.transport.ssl.truststore.path: /usr/share/elasticsearch/config/certs/elastic-certificates.p12
      xpack.security.http.ssl.enabled: true
      xpack.security.http.ssl.truststore.path: /usr/share/elasticsearch/config/certs/elastic-certificates.p12
      xpack.security.http.ssl.keystore.path: /usr/share/elasticsearch/config/certs/elastic-certificates.p12
  # mount a volume to access the certs as secrets
  secretMounts:
    - name: elastic-certificates
      secretName: elastic-certificates
      path: /usr/share/elasticsearch/config/certs
  extraEnvs:
  - name: ELASTIC_PASSWORD
    valueFrom:
      secretKeyRef:
        name: elastic-credentials
        key: password
  - name: ELASTIC_USERNAME
    valueFrom:
      secretKeyRef:
        name: elastic-credentials
        key: username


kibana:
  elasticsearchHosts: https://elasticsearch-master:9200/
  service:
    type: NodePort
    # Port the NodePort uses to access the service
    port: 5601
    # The port that the container exposes (default for kibana is 5601)
    targetPort: 5601
  protocol: https
  securityContext:
    capabilities:
      # drop the default linux superuser capabilities
      drop:
      - ALL
    # Needs to write a UUID file
    readOnlyRootFilesystem: false
    runAsNonRoot: true
    runAsUser: 1000
  secretMounts:
      - name: elastic-certificate-pem
        secretName: elastic-certificate-pem
        path: /usr/share/kibana/config/certs
  kibanaConfig:
    kibana.yml: |
        server.ssl:
          enabled: true
          key: /usr/share/kibana/config/certs/elastic-certificate.pem
          certificate: /usr/share/kibana/config/certs/elastic-certificate.pem
        xpack.security.encryptionKey: ${KIBANA_ENCRYPTION_KEY}
        xpack.encryptedSavedObjects.encryptionKey: fhjskloppd678ehkdfdlliverpoolfcr2134231
        elasticsearch.ssl:
          certificateAuthorities: /usr/share/kibana/config/certs/elastic-certificate.pem
          verificationMode: certificate
  extraEnvs:
  - name: ELASTICSEARCH_PASSWORD
    valueFrom:
      secretKeyRef:
        name: elastic-credentials
        key: password
  - name: ELASTICSEARCH_USERNAME
    valueFrom:
      secretKeyRef:
        name: elastic-credentials
        key: username
  - name: KIBANA_ENCRYPTION_KEY
    valueFrom:
      secretKeyRef:
        name: kibana
        key: encryptionkey
  readinessProbe:
    initialDelaySeconds: 30

elastalert:
  elasticsearch:
    host: elasticsearch-master
    port: 9200
    useSsl: true
    verifyCerts: false
    credentialsSecret: elastic-credentials
    credentialsSecretUsernameKey: username
    credentialsSecretPasswordKey: password